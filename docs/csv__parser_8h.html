<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>csvParser: csv_parser.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">csvParser
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('csv__parser_8h.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">csv_parser.h File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>A Library for parsing CSV files. csvParser is header only library, to use this, just include this file.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;assert.h&gt;</code><br />
<code>#include &lt;stdlib.h&gt;</code><br />
<code>#include &lt;string.h&gt;</code><br />
<code>#include &lt;stdio.h&gt;</code><br />
<code>#include &lt;stdint.h&gt;</code><br />
</div>
<p><a href="csv__parser_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_c_s_v___p_a_r_s_e_r.html">CSV_PARSER</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_c_s_v___p_a_r_s_e_r.html">CSV_PARSER</a> is passed to Buffer Loading Procedures and gets filled by these functions  <a href="struct_c_s_v___p_a_r_s_e_r.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a13e6e20ac03cc151394cdd1c4f08e922"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="csv__parser_8h.html#a13e6e20ac03cc151394cdd1c4f08e922">CSV_PARSER_API</a>&#160;&#160;&#160;extern</td></tr>
<tr class="memdesc:a13e6e20ac03cc151394cdd1c4f08e922"><td class="mdescLeft">&#160;</td><td class="mdescRight">The compilation configuration can be static and extern, by default it is extern. If static compilation for all the API is required, then CSV_PARSER_API_STATIC needs to get defined before including <a class="el" href="csv__parser_8h.html" title="A Library for parsing CSV files. csvParser is header only library, to use this, just include this fil...">csv_parser.h</a>.  <a href="csv__parser_8h.html#a13e6e20ac03cc151394cdd1c4f08e922">More...</a><br /></td></tr>
<tr class="separator:a13e6e20ac03cc151394cdd1c4f08e922"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee1c3212219b2743920d315786991128"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="csv__parser_8h.html#aee1c3212219b2743920d315786991128">CSV_PARSER_DEFN_API</a></td></tr>
<tr class="separator:aee1c3212219b2743920d315786991128"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2baa10a0c843ce22972b1588b7e7a4f2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="csv__parser_8h.html#a2baa10a0c843ce22972b1588b7e7a4f2">CSV_PARSER_ASSERT</a>&#160;&#160;&#160;assert</td></tr>
<tr class="memdesc:a2baa10a0c843ce22972b1588b7e7a4f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Custom assert can be used by defining CSV_PARSER_ASSERT before including <a class="el" href="csv__parser_8h.html" title="A Library for parsing CSV files. csvParser is header only library, to use this, just include this fil...">csv_parser.h</a>. When custom assert is used, assert.h is not included.  <a href="csv__parser_8h.html#a2baa10a0c843ce22972b1588b7e7a4f2">More...</a><br /></td></tr>
<tr class="separator:a2baa10a0c843ce22972b1588b7e7a4f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea1c72132c3b160a453d6014da91197d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="csv__parser_8h.html#aea1c72132c3b160a453d6014da91197d">CSV_PARSER_MALLOC</a>(size,  context)&#160;&#160;&#160;malloc(size)</td></tr>
<tr class="memdesc:aea1c72132c3b160a453d6014da91197d"><td class="mdescLeft">&#160;</td><td class="mdescRight">To use custom allocators, CSV_PARSER_MALLOC and CSV_PARSER_FREE both needs to get redefined before including <a class="el" href="csv__parser_8h.html" title="A Library for parsing CSV files. csvParser is header only library, to use this, just include this fil...">csv_parser.h</a>. When custom allocators are used, stdlib.h is not included.  <a href="csv__parser_8h.html#aea1c72132c3b160a453d6014da91197d">More...</a><br /></td></tr>
<tr class="separator:aea1c72132c3b160a453d6014da91197d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf8634ca68cd85739479009f26c8d46c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="csv__parser_8h.html#adf8634ca68cd85739479009f26c8d46c">CSV_PARSER_FREE</a>(ptr,  context)&#160;&#160;&#160;free(ptr)</td></tr>
<tr class="separator:adf8634ca68cd85739479009f26c8d46c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64664cb046b186ca9400fe8e257a6776"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="csv__parser_8h.html#a64664cb046b186ca9400fe8e257a6776">CSV_PARSER_MEMCPY</a>&#160;&#160;&#160;memcpy</td></tr>
<tr class="memdesc:a64664cb046b186ca9400fe8e257a6776"><td class="mdescLeft">&#160;</td><td class="mdescRight">To use custom memcpy, CSV_PARSER_MEMCPY needs to get redefined before including <a class="el" href="csv__parser_8h.html" title="A Library for parsing CSV files. csvParser is header only library, to use this, just include this fil...">csv_parser.h</a>. When custom memcpy is used, string.h is not included.  <a href="csv__parser_8h.html#a64664cb046b186ca9400fe8e257a6776">More...</a><br /></td></tr>
<tr class="separator:a64664cb046b186ca9400fe8e257a6776"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59f65f5b062d8ec89534e1a18a01f902"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="csv__parser_8h.html#a59f65f5b062d8ec89534e1a18a01f902">CSV_PARSER_STDIO_INCLUDED</a></td></tr>
<tr class="memdesc:a59f65f5b062d8ec89534e1a18a01f902"><td class="mdescLeft">&#160;</td><td class="mdescRight">To replace including stdio.h, define CSV_PARSER_NO_STDIO before including <a class="el" href="csv__parser_8h.html" title="A Library for parsing CSV files. csvParser is header only library, to use this, just include this fil...">csv_parser.h</a>.  <a href="csv__parser_8h.html#a59f65f5b062d8ec89534e1a18a01f902">More...</a><br /></td></tr>
<tr class="separator:a59f65f5b062d8ec89534e1a18a01f902"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:aac601275f88e8a66cdef9ea57b61b4e0"><td class="memItemLeft" align="right" valign="top">typedef int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="csv__parser_8h.html#aac601275f88e8a66cdef9ea57b61b4e0">CSV_PARSER_Bool</a></td></tr>
<tr class="separator:aac601275f88e8a66cdef9ea57b61b4e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b1d52f64244cc18332dbf9f35d9d4c8"><td class="memItemLeft" align="right" valign="top"><a id="a7b1d52f64244cc18332dbf9f35d9d4c8" name="a7b1d52f64244cc18332dbf9f35d9d4c8"></a>
typedef struct <a class="el" href="struct_c_s_v___p_a_r_s_e_r.html">CSV_PARSER</a>&#160;</td><td class="memItemRight" valign="bottom"><b>CSV_PARSER</b></td></tr>
<tr class="separator:a7b1d52f64244cc18332dbf9f35d9d4c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a863cb20e67643ea5dde0840b6e9ab3e1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="csv__parser_8h.html#a13e6e20ac03cc151394cdd1c4f08e922">CSV_PARSER_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="csv__parser_8h.html#a863cb20e67643ea5dde0840b6e9ab3e1">csv_parser_init</a> (<a class="el" href="struct_c_s_v___p_a_r_s_e_r.html">CSV_PARSER</a> *parser, void *allocator_context)</td></tr>
<tr class="memdesc:a863cb20e67643ea5dde0840b6e9ab3e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes <a class="el" href="struct_c_s_v___p_a_r_s_e_r.html">CSV_PARSER</a> with the allocator context Allocator context is the user data which is passed to <a class="el" href="csv__parser_8h.html#aeba9fe797472bf619a03fb4a71a9ad2e">csv_parser_malloc</a> and <a class="el" href="csv__parser_8h.html#a24f74c3d9390c781c53ca1d7156ae9d9">csv_parser_free</a>. Other values are set to default values. This procedure must be called before loading the CSV buffer.  <a href="csv__parser_8h.html#a863cb20e67643ea5dde0840b6e9ab3e1">More...</a><br /></td></tr>
<tr class="separator:a863cb20e67643ea5dde0840b6e9ab3e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeba9fe797472bf619a03fb4a71a9ad2e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="csv__parser_8h.html#a13e6e20ac03cc151394cdd1c4f08e922">CSV_PARSER_API</a> void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="csv__parser_8h.html#aeba9fe797472bf619a03fb4a71a9ad2e">csv_parser_malloc</a> (size_t size, void *context)</td></tr>
<tr class="memdesc:aeba9fe797472bf619a03fb4a71a9ad2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">CSV procedure to allocate memory. By default uses malloc from standard C library. To use custom allocator, see <a class="el" href="csv__parser_8h.html#aea1c72132c3b160a453d6014da91197d">here</a>.  <a href="csv__parser_8h.html#aeba9fe797472bf619a03fb4a71a9ad2e">More...</a><br /></td></tr>
<tr class="separator:aeba9fe797472bf619a03fb4a71a9ad2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24f74c3d9390c781c53ca1d7156ae9d9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="csv__parser_8h.html#a13e6e20ac03cc151394cdd1c4f08e922">CSV_PARSER_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="csv__parser_8h.html#a24f74c3d9390c781c53ca1d7156ae9d9">csv_parser_free</a> (void *ptr, void *context)</td></tr>
<tr class="memdesc:a24f74c3d9390c781c53ca1d7156ae9d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">CSV procedure to free memory allocated using <a class="el" href="csv__parser_8h.html#aeba9fe797472bf619a03fb4a71a9ad2e">csv_parser_malloc</a>. By default uses free from standard C library. To use custom allocator, see <a class="el" href="csv__parser_8h.html#aea1c72132c3b160a453d6014da91197d">here</a>.  <a href="csv__parser_8h.html#a24f74c3d9390c781c53ca1d7156ae9d9">More...</a><br /></td></tr>
<tr class="separator:a24f74c3d9390c781c53ca1d7156ae9d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89b84e2d7f014ce7b7f81f4d42560e70"><td class="memItemLeft" align="right" valign="top"><a class="el" href="csv__parser_8h.html#a13e6e20ac03cc151394cdd1c4f08e922">CSV_PARSER_API</a> uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="csv__parser_8h.html#a89b84e2d7f014ce7b7f81f4d42560e70">csv_parser_duplicate_buffer</a> (<a class="el" href="struct_c_s_v___p_a_r_s_e_r.html">CSV_PARSER</a> *parser, uint8_t *buffer, size_t length)</td></tr>
<tr class="memdesc:a89b84e2d7f014ce7b7f81f4d42560e70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates memory and copy and null terminates the given buffer using the allocator context present in given <a class="el" href="struct_c_s_v___p_a_r_s_e_r.html">CSV_PARSER</a>.  <a href="csv__parser_8h.html#a89b84e2d7f014ce7b7f81f4d42560e70">More...</a><br /></td></tr>
<tr class="separator:a89b84e2d7f014ce7b7f81f4d42560e70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc0efd6648f30a31e13c3575d2cb6315"><td class="memItemLeft" align="right" valign="top"><a class="el" href="csv__parser_8h.html#a13e6e20ac03cc151394cdd1c4f08e922">CSV_PARSER_API</a> CSV_PARSER_Bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="csv__parser_8h.html#abc0efd6648f30a31e13c3575d2cb6315">csv_parser_load_buffer</a> (<a class="el" href="struct_c_s_v___p_a_r_s_e_r.html">CSV_PARSER</a> *parser, uint8_t *buffer, size_t length)</td></tr>
<tr class="memdesc:abc0efd6648f30a31e13c3575d2cb6315"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads the CSV buffer for parsing. The buffer gets modified by this function. If the given buffer should not be modified, use <a class="el" href="csv__parser_8h.html#ae93b25c5ad52509f98d1d37d0c5f1350">csv_parser_load_duplicated</a> instead.  <a href="csv__parser_8h.html#abc0efd6648f30a31e13c3575d2cb6315">More...</a><br /></td></tr>
<tr class="separator:abc0efd6648f30a31e13c3575d2cb6315"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae93b25c5ad52509f98d1d37d0c5f1350"><td class="memItemLeft" align="right" valign="top"><a class="el" href="csv__parser_8h.html#a13e6e20ac03cc151394cdd1c4f08e922">CSV_PARSER_API</a> CSV_PARSER_Bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="csv__parser_8h.html#ae93b25c5ad52509f98d1d37d0c5f1350">csv_parser_load_duplicated</a> (<a class="el" href="struct_c_s_v___p_a_r_s_e_r.html">CSV_PARSER</a> *parser, uint8_t *buffer, size_t length)</td></tr>
<tr class="memdesc:ae93b25c5ad52509f98d1d37d0c5f1350"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads the CSV buffer by duplicating the original buffer by calling <a class="el" href="csv__parser_8h.html#a89b84e2d7f014ce7b7f81f4d42560e70">csv_parser_duplicate_buffer</a> Allocates memory for buffer. To release that memory <a class="el" href="csv__parser_8h.html#a5d534a4d85b64342d4aa9318da243505">csv_parser_release</a> must be called. This procedure should be used if modification of the original buffer is not intended. Calling this procedure is equivalent to <a class="el" href="csv__parser_8h.html#abc0efd6648f30a31e13c3575d2cb6315">csv_parser_load_buffer</a> after duplicating buffer using <a class="el" href="csv__parser_8h.html#a89b84e2d7f014ce7b7f81f4d42560e70">csv_parser_duplicate_buffer</a>.  <a href="csv__parser_8h.html#ae93b25c5ad52509f98d1d37d0c5f1350">More...</a><br /></td></tr>
<tr class="separator:ae93b25c5ad52509f98d1d37d0c5f1350"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7861cb89c257813c8e58a9907fd87c3b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="csv__parser_8h.html#a13e6e20ac03cc151394cdd1c4f08e922">CSV_PARSER_API</a> CSV_PARSER_Bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="csv__parser_8h.html#a7861cb89c257813c8e58a9907fd87c3b">csv_parser_load_file</a> (<a class="el" href="struct_c_s_v___p_a_r_s_e_r.html">CSV_PARSER</a> *parser, FILE *fp)</td></tr>
<tr class="memdesc:a7861cb89c257813c8e58a9907fd87c3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads the CSV buffer for parsing by reading from given FILE * Allocates memory for buffer. To release that memory <a class="el" href="csv__parser_8h.html#a5d534a4d85b64342d4aa9318da243505">csv_parser_release</a> must be called. The file is read as a whole even if the cursor of the file is not present at the start. The position of the cursor of the file handle will be at the end of the file if this procedure passes. The position of the cursor of the file handle is undefined if this procedure fails.  <a href="csv__parser_8h.html#a7861cb89c257813c8e58a9907fd87c3b">More...</a><br /></td></tr>
<tr class="separator:a7861cb89c257813c8e58a9907fd87c3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ababdd4199aa9eecfab1686da41cc34da"><td class="memItemLeft" align="right" valign="top"><a class="el" href="csv__parser_8h.html#a13e6e20ac03cc151394cdd1c4f08e922">CSV_PARSER_API</a> CSV_PARSER_Bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="csv__parser_8h.html#ababdd4199aa9eecfab1686da41cc34da">csv_parser_load</a> (<a class="el" href="struct_c_s_v___p_a_r_s_e_r.html">CSV_PARSER</a> *parser, const char *file_path)</td></tr>
<tr class="memdesc:ababdd4199aa9eecfab1686da41cc34da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads the file from the given file path, reads the CSV buffer from the file, loads the CSV buffer into <a class="el" href="struct_c_s_v___p_a_r_s_e_r.html">CSV_PARSER</a> Allocates memory for buffer. To release that memory <a class="el" href="csv__parser_8h.html#a5d534a4d85b64342d4aa9318da243505">csv_parser_release</a> must be called.  <a href="csv__parser_8h.html#ababdd4199aa9eecfab1686da41cc34da">More...</a><br /></td></tr>
<tr class="separator:ababdd4199aa9eecfab1686da41cc34da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d534a4d85b64342d4aa9318da243505"><td class="memItemLeft" align="right" valign="top"><a class="el" href="csv__parser_8h.html#a13e6e20ac03cc151394cdd1c4f08e922">CSV_PARSER_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="csv__parser_8h.html#a5d534a4d85b64342d4aa9318da243505">csv_parser_release</a> (<a class="el" href="struct_c_s_v___p_a_r_s_e_r.html">CSV_PARSER</a> *parser)</td></tr>
<tr class="memdesc:a5d534a4d85b64342d4aa9318da243505"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release the buffer allocated by using <a class="el" href="csv__parser_8h.html#ababdd4199aa9eecfab1686da41cc34da">csv_parser_load</a>, <a class="el" href="csv__parser_8h.html#a7861cb89c257813c8e58a9907fd87c3b">csv_parser_load_file</a> and <a class="el" href="csv__parser_8h.html#ae93b25c5ad52509f98d1d37d0c5f1350">csv_parser_load_duplicated</a>.  <a href="csv__parser_8h.html#a5d534a4d85b64342d4aa9318da243505">More...</a><br /></td></tr>
<tr class="separator:a5d534a4d85b64342d4aa9318da243505"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43d4ddea667509517f5ece853f559efa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="csv__parser_8h.html#a13e6e20ac03cc151394cdd1c4f08e922">CSV_PARSER_API</a> uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="csv__parser_8h.html#a43d4ddea667509517f5ece853f559efa">csv_parser_next</a> (<a class="el" href="struct_c_s_v___p_a_r_s_e_r.html">CSV_PARSER</a> *parser, size_t *length)</td></tr>
<tr class="memdesc:a43d4ddea667509517f5ece853f559efa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses the next element in the CSV buffer. This procedure is expected to be called in a loop of <a class="el" href="struct_c_s_v___p_a_r_s_e_r.html#af676690c02227588fa8615ad33aeab4c">CSV_PARSER::lines</a> and <a class="el" href="struct_c_s_v___p_a_r_s_e_r.html#a8f286185a216a03cae5eb89c39f19349">CSV_PARSER::columns</a>. The first <a class="el" href="struct_c_s_v___p_a_r_s_e_r.html#a8f286185a216a03cae5eb89c39f19349">CSV_PARSER::columns</a> values are always the heading of the CSV buffer.  <a href="csv__parser_8h.html#a43d4ddea667509517f5ece853f559efa">More...</a><br /></td></tr>
<tr class="separator:a43d4ddea667509517f5ece853f559efa"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >A Library for parsing CSV files. csvParser is header only library, to use this, just include this file. </p>

<p class="definition">Definition in file <a class="el" href="csv__parser_8h_source.html">csv_parser.h</a>.</p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a13e6e20ac03cc151394cdd1c4f08e922" name="a13e6e20ac03cc151394cdd1c4f08e922"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13e6e20ac03cc151394cdd1c4f08e922">&#9670;&nbsp;</a></span>CSV_PARSER_API</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CSV_PARSER_API&#160;&#160;&#160;extern</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The compilation configuration can be static and extern, by default it is extern. If static compilation for all the API is required, then CSV_PARSER_API_STATIC needs to get defined before including <a class="el" href="csv__parser_8h.html" title="A Library for parsing CSV files. csvParser is header only library, to use this, just include this fil...">csv_parser.h</a>. </p>

<p class="definition">Definition at line <a class="el" href="csv__parser_8h_source.html#l00019">19</a> of file <a class="el" href="csv__parser_8h_source.html">csv_parser.h</a>.</p>

</div>
</div>
<a id="a2baa10a0c843ce22972b1588b7e7a4f2" name="a2baa10a0c843ce22972b1588b7e7a4f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2baa10a0c843ce22972b1588b7e7a4f2">&#9670;&nbsp;</a></span>CSV_PARSER_ASSERT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CSV_PARSER_ASSERT&#160;&#160;&#160;assert</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Custom assert can be used by defining CSV_PARSER_ASSERT before including <a class="el" href="csv__parser_8h.html" title="A Library for parsing CSV files. csvParser is header only library, to use this, just include this fil...">csv_parser.h</a>. When custom assert is used, assert.h is not included. </p>

<p class="definition">Definition at line <a class="el" href="csv__parser_8h_source.html#l00036">36</a> of file <a class="el" href="csv__parser_8h_source.html">csv_parser.h</a>.</p>

</div>
</div>
<a id="aee1c3212219b2743920d315786991128" name="aee1c3212219b2743920d315786991128"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee1c3212219b2743920d315786991128">&#9670;&nbsp;</a></span>CSV_PARSER_DEFN_API</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CSV_PARSER_DEFN_API</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="csv__parser_8h_source.html#l00020">20</a> of file <a class="el" href="csv__parser_8h_source.html">csv_parser.h</a>.</p>

</div>
</div>
<a id="adf8634ca68cd85739479009f26c8d46c" name="adf8634ca68cd85739479009f26c8d46c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf8634ca68cd85739479009f26c8d46c">&#9670;&nbsp;</a></span>CSV_PARSER_FREE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CSV_PARSER_FREE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ptr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">context&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;free(ptr)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="csv__parser_8h_source.html#l00045">45</a> of file <a class="el" href="csv__parser_8h_source.html">csv_parser.h</a>.</p>

</div>
</div>
<a id="aea1c72132c3b160a453d6014da91197d" name="aea1c72132c3b160a453d6014da91197d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea1c72132c3b160a453d6014da91197d">&#9670;&nbsp;</a></span>CSV_PARSER_MALLOC</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CSV_PARSER_MALLOC</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">size, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">context&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;malloc(size)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>To use custom allocators, CSV_PARSER_MALLOC and CSV_PARSER_FREE both needs to get redefined before including <a class="el" href="csv__parser_8h.html" title="A Library for parsing CSV files. csvParser is header only library, to use this, just include this fil...">csv_parser.h</a>. When custom allocators are used, stdlib.h is not included. </p>

<p class="definition">Definition at line <a class="el" href="csv__parser_8h_source.html#l00044">44</a> of file <a class="el" href="csv__parser_8h_source.html">csv_parser.h</a>.</p>

</div>
</div>
<a id="a64664cb046b186ca9400fe8e257a6776" name="a64664cb046b186ca9400fe8e257a6776"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64664cb046b186ca9400fe8e257a6776">&#9670;&nbsp;</a></span>CSV_PARSER_MEMCPY</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CSV_PARSER_MEMCPY&#160;&#160;&#160;memcpy</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>To use custom memcpy, CSV_PARSER_MEMCPY needs to get redefined before including <a class="el" href="csv__parser_8h.html" title="A Library for parsing CSV files. csvParser is header only library, to use this, just include this fil...">csv_parser.h</a>. When custom memcpy is used, string.h is not included. </p>

<p class="definition">Definition at line <a class="el" href="csv__parser_8h_source.html#l00057">57</a> of file <a class="el" href="csv__parser_8h_source.html">csv_parser.h</a>.</p>

</div>
</div>
<a id="a59f65f5b062d8ec89534e1a18a01f902" name="a59f65f5b062d8ec89534e1a18a01f902"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59f65f5b062d8ec89534e1a18a01f902">&#9670;&nbsp;</a></span>CSV_PARSER_STDIO_INCLUDED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CSV_PARSER_STDIO_INCLUDED</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>To replace including stdio.h, define CSV_PARSER_NO_STDIO before including <a class="el" href="csv__parser_8h.html" title="A Library for parsing CSV files. csvParser is header only library, to use this, just include this fil...">csv_parser.h</a>. </p>

<p class="definition">Definition at line <a class="el" href="csv__parser_8h_source.html#l00064">64</a> of file <a class="el" href="csv__parser_8h_source.html">csv_parser.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="aac601275f88e8a66cdef9ea57b61b4e0" name="aac601275f88e8a66cdef9ea57b61b4e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac601275f88e8a66cdef9ea57b61b4e0">&#9670;&nbsp;</a></span>CSV_PARSER_Bool</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int32_t CSV_PARSER_Bool</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="csv__parser_8h_source.html#l00075">75</a> of file <a class="el" href="csv__parser_8h_source.html">csv_parser.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a89b84e2d7f014ce7b7f81f4d42560e70" name="a89b84e2d7f014ce7b7f81f4d42560e70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89b84e2d7f014ce7b7f81f4d42560e70">&#9670;&nbsp;</a></span>csv_parser_duplicate_buffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t * csv_parser_duplicate_buffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_c_s_v___p_a_r_s_e_r.html">CSV_PARSER</a> *&#160;</td>
          <td class="paramname"><em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates memory and copy and null terminates the given buffer using the allocator context present in given <a class="el" href="struct_c_s_v___p_a_r_s_e_r.html">CSV_PARSER</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parser</td><td>The parser whose allocator context is to be used for allocation </td></tr>
    <tr><td class="paramname">buffer</td><td>The buffer to be duplicated </td></tr>
    <tr><td class="paramname">length</td><td>The length of the given buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The duplicated and null terminated buffer </dd></dl>

</div>
</div>
<a id="a24f74c3d9390c781c53ca1d7156ae9d9" name="a24f74c3d9390c781c53ca1d7156ae9d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24f74c3d9390c781c53ca1d7156ae9d9">&#9670;&nbsp;</a></span>csv_parser_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void csv_parser_free </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>CSV procedure to free memory allocated using <a class="el" href="csv__parser_8h.html#aeba9fe797472bf619a03fb4a71a9ad2e">csv_parser_malloc</a>. By default uses free from standard C library. To use custom allocator, see <a class="el" href="csv__parser_8h.html#aea1c72132c3b160a453d6014da91197d">here</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>The pointer to the memory to be freed. Must be the pointer returned by <a class="el" href="csv__parser_8h.html#aeba9fe797472bf619a03fb4a71a9ad2e">csv_parser_malloc</a> </td></tr>
    <tr><td class="paramname">context</td><td>The allocator context </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a863cb20e67643ea5dde0840b6e9ab3e1" name="a863cb20e67643ea5dde0840b6e9ab3e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a863cb20e67643ea5dde0840b6e9ab3e1">&#9670;&nbsp;</a></span>csv_parser_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void csv_parser_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_c_s_v___p_a_r_s_e_r.html">CSV_PARSER</a> *&#160;</td>
          <td class="paramname"><em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>allocator_context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes <a class="el" href="struct_c_s_v___p_a_r_s_e_r.html">CSV_PARSER</a> with the allocator context Allocator context is the user data which is passed to <a class="el" href="csv__parser_8h.html#aeba9fe797472bf619a03fb4a71a9ad2e">csv_parser_malloc</a> and <a class="el" href="csv__parser_8h.html#a24f74c3d9390c781c53ca1d7156ae9d9">csv_parser_free</a>. Other values are set to default values. This procedure must be called before loading the CSV buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parser</td><td>The pointer to <a class="el" href="struct_c_s_v___p_a_r_s_e_r.html">CSV_PARSER</a> to be initialized </td></tr>
    <tr><td class="paramname">allocator_context</td><td>The allocator context </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ababdd4199aa9eecfab1686da41cc34da" name="ababdd4199aa9eecfab1686da41cc34da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ababdd4199aa9eecfab1686da41cc34da">&#9670;&nbsp;</a></span>csv_parser_load()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSV_PARSER_Bool csv_parser_load </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_c_s_v___p_a_r_s_e_r.html">CSV_PARSER</a> *&#160;</td>
          <td class="paramname"><em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file_path</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Loads the file from the given file path, reads the CSV buffer from the file, loads the CSV buffer into <a class="el" href="struct_c_s_v___p_a_r_s_e_r.html">CSV_PARSER</a> Allocates memory for buffer. To release that memory <a class="el" href="csv__parser_8h.html#a5d534a4d85b64342d4aa9318da243505">csv_parser_release</a> must be called. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parser</td><td>Parser where the CSV buffer is to be associated with </td></tr>
    <tr><td class="paramname">file_path</td><td>The path to the CSV file </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Non zero if the read CSV buffer is valid. If zero, loading CSV buffer failed and error message is stored in <a class="el" href="struct_c_s_v___p_a_r_s_e_r.html#aae4eb022eb407d1ab238d99fc9342a01">CSV_PARSER::error</a> </dd></dl>

</div>
</div>
<a id="abc0efd6648f30a31e13c3575d2cb6315" name="abc0efd6648f30a31e13c3575d2cb6315"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc0efd6648f30a31e13c3575d2cb6315">&#9670;&nbsp;</a></span>csv_parser_load_buffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSV_PARSER_Bool csv_parser_load_buffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_c_s_v___p_a_r_s_e_r.html">CSV_PARSER</a> *&#160;</td>
          <td class="paramname"><em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Loads the CSV buffer for parsing. The buffer gets modified by this function. If the given buffer should not be modified, use <a class="el" href="csv__parser_8h.html#ae93b25c5ad52509f98d1d37d0c5f1350">csv_parser_load_duplicated</a> instead. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parser</td><td>Parser where the buffer is to be associated with </td></tr>
    <tr><td class="paramname">buffer</td><td>The CSV buffer. The buffer must be null terminated </td></tr>
    <tr><td class="paramname">length</td><td>The length of the buffer. The length of the buffer MUST not count the null terminator </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Non zero if the passed CSV buffer is valid. If zero, loading CSV buffer failed and error message is stored in <a class="el" href="struct_c_s_v___p_a_r_s_e_r.html#aae4eb022eb407d1ab238d99fc9342a01">CSV_PARSER::error</a> </dd></dl>

</div>
</div>
<a id="ae93b25c5ad52509f98d1d37d0c5f1350" name="ae93b25c5ad52509f98d1d37d0c5f1350"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae93b25c5ad52509f98d1d37d0c5f1350">&#9670;&nbsp;</a></span>csv_parser_load_duplicated()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSV_PARSER_Bool csv_parser_load_duplicated </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_c_s_v___p_a_r_s_e_r.html">CSV_PARSER</a> *&#160;</td>
          <td class="paramname"><em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Loads the CSV buffer by duplicating the original buffer by calling <a class="el" href="csv__parser_8h.html#a89b84e2d7f014ce7b7f81f4d42560e70">csv_parser_duplicate_buffer</a> Allocates memory for buffer. To release that memory <a class="el" href="csv__parser_8h.html#a5d534a4d85b64342d4aa9318da243505">csv_parser_release</a> must be called. This procedure should be used if modification of the original buffer is not intended. Calling this procedure is equivalent to <a class="el" href="csv__parser_8h.html#abc0efd6648f30a31e13c3575d2cb6315">csv_parser_load_buffer</a> after duplicating buffer using <a class="el" href="csv__parser_8h.html#a89b84e2d7f014ce7b7f81f4d42560e70">csv_parser_duplicate_buffer</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parser</td><td>Parser where the duplicated buffer is to be associated with </td></tr>
    <tr><td class="paramname">buffer</td><td>The CSV buffer. The buffer may or may not be null terminated </td></tr>
    <tr><td class="paramname">length</td><td>The length of the buffer. The length of the buffer MUST not count the null terminator if null terminator is present in the given buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Non zero if the passed CSV buffer is valid. If zero, loading CSV buffer failed and error message is stored in <a class="el" href="struct_c_s_v___p_a_r_s_e_r.html">CSV_PARSER</a>.error </dd></dl>

</div>
</div>
<a id="a7861cb89c257813c8e58a9907fd87c3b" name="a7861cb89c257813c8e58a9907fd87c3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7861cb89c257813c8e58a9907fd87c3b">&#9670;&nbsp;</a></span>csv_parser_load_file()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSV_PARSER_Bool csv_parser_load_file </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_c_s_v___p_a_r_s_e_r.html">CSV_PARSER</a> *&#160;</td>
          <td class="paramname"><em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>fp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Loads the CSV buffer for parsing by reading from given FILE * Allocates memory for buffer. To release that memory <a class="el" href="csv__parser_8h.html#a5d534a4d85b64342d4aa9318da243505">csv_parser_release</a> must be called. The file is read as a whole even if the cursor of the file is not present at the start. The position of the cursor of the file handle will be at the end of the file if this procedure passes. The position of the cursor of the file handle is undefined if this procedure fails. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parser</td><td>Parser where the buffer is to be associated with </td></tr>
    <tr><td class="paramname">fp</td><td>The file handle which is to be read to load the buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Non zero if the read CSV buffer is valid. If zero, loading CSV buffer failed and error message is stored in <a class="el" href="struct_c_s_v___p_a_r_s_e_r.html#aae4eb022eb407d1ab238d99fc9342a01">CSV_PARSER::error</a> </dd></dl>

</div>
</div>
<a id="aeba9fe797472bf619a03fb4a71a9ad2e" name="aeba9fe797472bf619a03fb4a71a9ad2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeba9fe797472bf619a03fb4a71a9ad2e">&#9670;&nbsp;</a></span>csv_parser_malloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * csv_parser_malloc </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>CSV procedure to allocate memory. By default uses malloc from standard C library. To use custom allocator, see <a class="el" href="csv__parser_8h.html#aea1c72132c3b160a453d6014da91197d">here</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>The size of the memory yo be allocated </td></tr>
    <tr><td class="paramname">context</td><td>The allocator context </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The pointer to allocated memory </dd></dl>

</div>
</div>
<a id="a43d4ddea667509517f5ece853f559efa" name="a43d4ddea667509517f5ece853f559efa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43d4ddea667509517f5ece853f559efa">&#9670;&nbsp;</a></span>csv_parser_next()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t * csv_parser_next </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_c_s_v___p_a_r_s_e_r.html">CSV_PARSER</a> *&#160;</td>
          <td class="paramname"><em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parses the next element in the CSV buffer. This procedure is expected to be called in a loop of <a class="el" href="struct_c_s_v___p_a_r_s_e_r.html#af676690c02227588fa8615ad33aeab4c">CSV_PARSER::lines</a> and <a class="el" href="struct_c_s_v___p_a_r_s_e_r.html#a8f286185a216a03cae5eb89c39f19349">CSV_PARSER::columns</a>. The first <a class="el" href="struct_c_s_v___p_a_r_s_e_r.html#a8f286185a216a03cae5eb89c39f19349">CSV_PARSER::columns</a> values are always the heading of the CSV buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parser</td><td>The parser whose next element should be parsed </td></tr>
    <tr><td class="paramname">length</td><td>Returns the length of the UTF-8 string returned </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The UTF-8 string of the next element </dd></dl>

</div>
</div>
<a id="a5d534a4d85b64342d4aa9318da243505" name="a5d534a4d85b64342d4aa9318da243505"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d534a4d85b64342d4aa9318da243505">&#9670;&nbsp;</a></span>csv_parser_release()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void csv_parser_release </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_c_s_v___p_a_r_s_e_r.html">CSV_PARSER</a> *&#160;</td>
          <td class="paramname"><em>parser</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Release the buffer allocated by using <a class="el" href="csv__parser_8h.html#ababdd4199aa9eecfab1686da41cc34da">csv_parser_load</a>, <a class="el" href="csv__parser_8h.html#a7861cb89c257813c8e58a9907fd87c3b">csv_parser_load_file</a> and <a class="el" href="csv__parser_8h.html#ae93b25c5ad52509f98d1d37d0c5f1350">csv_parser_load_duplicated</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parser</td><td>The parser whose buffer is to be released </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="csv__parser_8h.html">csv_parser.h</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.2 </li>
  </ul>
</div>
</body>
</html>
